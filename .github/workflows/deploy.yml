name: Deploy by checkout, screenshot, merge and push

on:
  push:
    branches: ["master"]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: "deploy-screenshots"
  cancel-in-progress: false

jobs:
  update-screenshots-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for lockfile
        id: check-lock
        run: |
          if [ -f package-lock.json ] || [ -f npm-shrinkwrap.json ] || [ -f yarn.lock ]; then
            echo "lockfile=true" >> $GITHUB_OUTPUT
          else
            echo "lockfile=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Ruby for Jekyll preview
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.1"
          bundler-cache: true
          cache-version: 0

      - name: Setup Node.js (no automatic cache)
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Restore npm cache (only when lockfile present)
        if: ${{ steps.check-lock.outputs.lockfile == 'true' }}
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json','**/npm-shrinkwrap.json','**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install npm dependencies (lockfile present -> npm ci)
        if: ${{ steps.check-lock.outputs.lockfile == 'true' }}
        run: npm ci
        env:
          CI: "true"

      - name: Install npm dependencies (no lockfile -> npm install)
        if: ${{ steps.check-lock.outputs.lockfile == 'false' }}
        run: npm install --no-audit --no-fund
        env:
          CI: "true"

      - name: Start local server and wait for availability
        # Start the server in the background and poll until it responds before continuing
        run: |
          npm run serve &>/tmp/serve.log &
          echo "Started local server, logging to /tmp/serve.log"
          # Wait up to 60 seconds for the server to become available on 127.0.0.1:4000
          MAX_WAIT=60
          URL="${{ env.SCREENSHOT_URL_OVERRIDE || 'http://127.0.0.1:4000/' }}"
          for i in $(seq 1 $MAX_WAIT); do
            if curl -sS --fail "$URL" >/dev/null 2>&1; then
              echo "Server is up at $URL (after $i seconds)"
              break
            fi
            echo "Waiting for server at $URL... ($i/$MAX_WAIT)"
            sleep 1
          done
          if ! curl -sS --fail "$URL" >/dev/null 2>&1; then
            echo "Server did not become available within ${MAX_WAIT}s"
            echo "---- /tmp/serve.log (last 200 lines) ----"
            tail -n 200 /tmp/serve.log || true
            exit 1
          fi
        env:
          CI: "true"

      - name: Run screenshot script
        run: npm run ss
        env:
          # Ensure the screenshot script targets the same URL we waited on above.
          # You can override this when dispatching the workflow by setting SCREENSHOT_URL_OVERRIDE.
          SCREENSHOT_URL: ${{ env.SCREENSHOT_URL_OVERRIDE || 'http://127.0.0.1:4000/' }}
          # Output directory for screenshots (matches the script's default)
          SCREENSHOT_DIR: assets/og

      - name: Prepare git for deploy branch operations
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git fetch origin --prune

      - name: Checkout (or create) deploy branch
        run: |
          TARGET_BRANCH="deploy"
          if git ls-remote --heads origin "${TARGET_BRANCH}" | grep -q "${TARGET_BRANCH}"; then
            git checkout "${TARGET_BRANCH}"
            git reset --hard "origin/${TARGET_BRANCH}"
          else
            git checkout --orphan "${TARGET_BRANCH}"
            git rm -rf .
            # create an initial empty commit so branch exists
            git commit --allow-empty -m "Initialize ${TARGET_BRANCH} branch"
            git push origin "${TARGET_BRANCH}"
          fi

      - name: Merge latest master into deploy
        run: |
          # Ensure we have the latest master
          git fetch origin master:refs/remotes/origin/master
          # Merge changes from master; prefer theirs if conflicts to keep deploy content stable,
          # but allow automatic merges. Adjust strategy as needed.
          git merge --no-edit origin/master || git merge --no-edit -X theirs origin/master || true

      - name: Copy/update screenshots (if generated in working tree)
        run: |
          # If your screenshot script outputs to a specific dir (e.g. assets/og/), ensure it's staged.
          # Adjust the path below if your screenshots are output elsewhere.
          SCREENSHOT_DIR="assets/og"
          if [ -d "${SCREENSHOT_DIR}" ]; then
            git add "${SCREENSHOT_DIR}"
          else
            echo "Screenshot directory ${SCREENSHOT_DIR} not found; skipping add."
          fi

      - name: Commit and push screenshots via a temporary branch to avoid checkout conflicts
        run: |
          # Strategy:
          # 1) Create a temporary branch from the current HEAD, commit the screenshots there.
          # 2) Checkout (or create) the deploy branch.
          # 3) Pull the screenshots from the temporary branch into deploy using `git checkout tmp -- path`.
          # 4) Commit & push only the screenshots to deploy.
          #
          # This avoids leaving uncommitted changes in the working tree that block branch checkout
          # and ensures we never push the current HEAD to master accidentally.

          SCREENSHOT_DIR="assets/og"
          TMP_BRANCH="tmp-screenshots-${GITHUB_RUN_ID:-manual}-${GITHUB_RUN_NUMBER:-0}"
          TARGET_BRANCH="deploy"

          echo "Temporary branch will be: ${TMP_BRANCH}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create temp branch from current HEAD (this keeps current working tree intact)
          git checkout -b "${TMP_BRANCH}"

          # Stage screenshots (if present) and commit on the temp branch
          if [ -d "${SCREENSHOT_DIR}" ]; then
            git add -- "${SCREENSHOT_DIR}"
            if [ -n "$(git diff --cached --name-only)" ]; then
              git commit -m "Temp: capture screenshots [ci skip]" || true
            else
              echo "No screenshot changes to commit on temp branch."
            fi
          else
            echo "No ${SCREENSHOT_DIR} present on workspace to commit."
          fi

          # Push the temp branch to the remote so we can reference its tree safely
          git push --set-upstream origin "${TMP_BRANCH}" || true

          # Fetch and prepare the deploy branch
          git fetch origin --prune
          if git ls-remote --heads origin "${TARGET_BRANCH}" | grep -q "${TARGET_BRANCH}"; then
            git checkout "${TARGET_BRANCH}"
            git reset --mixed "origin/${TARGET_BRANCH}" || true
          else
            git checkout --orphan "${TARGET_BRANCH}"
            git rm -rf .
            git commit --allow-empty -m "Initialize ${TARGET_BRANCH} branch"
          fi

          # Ensure any tracked build artifacts are removed from index
          git rm -r --cached --ignore-unmatch _site .bundle vendor node_modules || true
          git rm --cached --ignore-unmatch Gemfile.lock package-lock.json || true

          # Pull screenshots from the temp branch into the deploy branch working tree
          if git show --name-only --pretty=format: "origin/${TMP_BRANCH}:${SCREENSHOT_DIR}" >/dev/null 2>&1; then
            :
          fi
          # Using `git checkout <branch> -- <path>` to copy files from the temp branch into current branch
          git checkout "${TMP_BRANCH}" -- "${SCREENSHOT_DIR}" || true

          # Stage and commit only the screenshots (if any)
          if [ -d "${SCREENSHOT_DIR}" ]; then
            git add -- "${SCREENSHOT_DIR}"
            if [ -n "$(git diff --cached --name-only)" ]; then
              git commit -m "Update screenshots from master [skip ci]" || true
              git push origin HEAD:deploy --follow-tags
            else
              echo "No staged screenshot changes to commit."
            fi
          else
            echo "No screenshots found to add to deploy branch."
          fi

          # Cleanup: delete temporary branch locally and remotely
          git checkout - >/dev/null 2>&1 || true
          git branch -D "${TMP_BRANCH}" >/dev/null 2>&1 || true
          git push origin --delete "${TMP_BRANCH}" >/dev/null 2>&1 || true

      - name: Show pushed branch info
        run: |
          echo "Deployed branch: $(git rev-parse --abbrev-ref HEAD)"
          git --no-pager log -n 3 --oneline
