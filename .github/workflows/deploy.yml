name: Deploy by checkout, screenshot, merge and push

on:
  push:
    branches: ["master"]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: "deploy-screenshots"
  cancel-in-progress: false

jobs:
  update-screenshots-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for lockfile
        id: check-lock
        run: |
          if [ -f package-lock.json ] || [ -f npm-shrinkwrap.json ] || [ -f yarn.lock ]; then
            echo "lockfile=true" >> $GITHUB_OUTPUT
          else
            echo "lockfile=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Ruby for Jekyll preview
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.1"
          bundler-cache: true
          cache-version: 0

      - name: Setup Node.js (no automatic cache)
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Restore npm cache (only when lockfile present)
        if: ${{ steps.check-lock.outputs.lockfile == 'true' }}
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json','**/npm-shrinkwrap.json','**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Install npm dependencies (lockfile present -> npm ci)
        if: ${{ steps.check-lock.outputs.lockfile == 'true' }}
        run: npm ci
        env:
          CI: "true"

      - name: Install npm dependencies (no lockfile -> npm install)
        if: ${{ steps.check-lock.outputs.lockfile == 'false' }}
        run: npm install --no-audit --no-fund
        env:
          CI: "true"

      - name: Start local server and wait for availability
        # Start the server in the background and poll until it responds before continuing
        run: |
          npm run serve &>/tmp/serve.log &
          echo "Started local server, logging to /tmp/serve.log"
          # Wait up to 60 seconds for the server to become available on 127.0.0.1:4000
          MAX_WAIT=60
          URL="${{ env.SCREENSHOT_URL_OVERRIDE || 'http://127.0.0.1:4000/' }}"
          for i in $(seq 1 $MAX_WAIT); do
            if curl -sS --fail "$URL" >/dev/null 2>&1; then
              echo "Server is up at $URL (after $i seconds)"
              break
            fi
            echo "Waiting for server at $URL... ($i/$MAX_WAIT)"
            sleep 1
          done
          if ! curl -sS --fail "$URL" >/dev/null 2>&1; then
            echo "Server did not become available within ${MAX_WAIT}s"
            echo "---- /tmp/serve.log (last 200 lines) ----"
            tail -n 200 /tmp/serve.log || true
            exit 1
          fi
        env:
          CI: "true"

      - name: Run screenshot script
        run: npm run ss
        env:
          # Ensure the screenshot script targets the same URL we waited on above.
          # You can override this when dispatching the workflow by setting SCREENSHOT_URL_OVERRIDE.
          SCREENSHOT_URL: ${{ env.SCREENSHOT_URL_OVERRIDE || 'http://127.0.0.1:4000/' }}
          # Output directory for screenshots (matches the script's default)
          SCREENSHOT_DIR: assets/og

      - name: Prepare git for deploy branch operations
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git fetch origin --prune

      - name: Checkout (or create) deploy branch
        run: |
          TARGET_BRANCH="deploy"
          if git ls-remote --heads origin "${TARGET_BRANCH}" | grep -q "${TARGET_BRANCH}"; then
            git checkout "${TARGET_BRANCH}"
            git reset --hard "origin/${TARGET_BRANCH}"
          else
            git checkout --orphan "${TARGET_BRANCH}"
            git rm -rf .
            # create an initial empty commit so branch exists
            git commit --allow-empty -m "Initialize ${TARGET_BRANCH} branch"
            git push origin "${TARGET_BRANCH}"
          fi

      - name: Merge latest master into deploy
        run: |
          # Ensure we have the latest master
          git fetch origin master:refs/remotes/origin/master
          # Merge changes from master; prefer theirs if conflicts to keep deploy content stable,
          # but allow automatic merges. Adjust strategy as needed.
          git merge --no-edit origin/master || git merge --no-edit -X theirs origin/master || true

      - name: Copy/update screenshots (if generated in working tree)
        run: |
          # If your screenshot script outputs to a specific dir (e.g. assets/og/), ensure it's staged.
          # Adjust the path below if your screenshots are output elsewhere.
          SCREENSHOT_DIR="assets/og"
          if [ -d "${SCREENSHOT_DIR}" ]; then
            git add "${SCREENSHOT_DIR}"
          else
            echo "Screenshot directory ${SCREENSHOT_DIR} not found; skipping add."
          fi

      - name: Commit and push changes if any (only screenshots -> deploy)
        run: |
          # Move screenshot output out of the working tree to avoid checkout conflicts,
          # then restore it into the deploy branch for commit.
          SCREENSHOT_DIR="assets/og"
          BACKUP_DIR="$(mktemp -d)"
          echo "Using backup dir: ${BACKUP_DIR}"

          if [ -d "${SCREENSHOT_DIR}" ]; then
            # move the directory to backup so checkout won't be blocked by local changes
            echo "Temporarily moving ${SCREENSHOT_DIR} to ${BACKUP_DIR}"
            mv "${SCREENSHOT_DIR}" "${BACKUP_DIR}/" || true
          else
            echo "No existing ${SCREENSHOT_DIR} in working tree to back up."
          fi

          TARGET_BRANCH="deploy"

          # Ensure remote refs are available
          git fetch origin --prune

          # Create or checkout the deploy branch safely now that screenshots are moved
          if git rev-parse --verify "${TARGET_BRANCH}" >/dev/null 2>&1; then
            git checkout "${TARGET_BRANCH}"
            git reset --mixed "origin/${TARGET_BRANCH}" || true
          else
            git checkout --orphan "${TARGET_BRANCH}"
            git rm -rf .
            git commit --allow-empty -m "Initialize ${TARGET_BRANCH} branch"
          fi

          # Remove any tracked build artifacts from the index to prevent accidental commits
          git rm -r --cached --ignore-unmatch _site .bundle vendor node_modules || true
          git rm --cached --ignore-unmatch Gemfile.lock package-lock.json || true

          # Restore screenshots from backup into the working tree in the correct location
          if [ -d "${BACKUP_DIR}/og" ]; then
            mkdir -p assets
            mv "${BACKUP_DIR}/og" assets/ || true
          elif [ -d "${BACKUP_DIR}/assets/og" ]; then
            mkdir -p assets
            mv "${BACKUP_DIR}/assets/og" assets/og || true
          else
            echo "No screenshots found in backup; nothing to restore."
          fi

          # Stage only the screenshots directory (if present)
          if [ -d "${SCREENSHOT_DIR}" ]; then
            git add -- "${SCREENSHOT_DIR}"
          else
            echo "Screenshot directory ${SCREENSHOT_DIR} not found in deploy branch; nothing to add."
          fi

          # Commit only if there are staged changes
          if [ -n "$(git diff --cached --name-only)" ]; then
            git commit -m "Update screenshots from master [skip ci]" || true
            # Always push to the deploy branch explicitly to avoid pushing to the event branch
            git push origin HEAD:deploy --follow-tags
          else
            echo "No staged changes to commit."
          fi

          # Cleanup any backup left behind
          if [ -d "${BACKUP_DIR}" ]; then
            rm -rf "${BACKUP_DIR}" || true
          fi

      - name: Show pushed branch info
        run: |
          echo "Deployed branch: $(git rev-parse --abbrev-ref HEAD)"
          git --no-pager log -n 3 --oneline
